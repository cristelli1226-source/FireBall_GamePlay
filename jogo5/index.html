<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TETRIS - Flamezera Edition</title>
  <style>
    :root {
      --bg: #0b1220;
      --panel: #0f1724;
      --accent: #ff6b35;
      --muted: #9aa6b2;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      background: linear-gradient(180deg, #071021 0%, #0b1220 100%);
      color: #e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
      margin: 0;
      display: flex;
      min-height: 100vh;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    /* Tela inicial - VIS√çVEL por padr√£o */
    #startScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #071021 0%, #0b1220 100%);
      z-index: 10;
    }
    
    .logo {
      font-size: 3.5rem;
      font-weight: bold;
      text-align: center;
      margin-bottom: 2rem;
      background: linear-gradient(to right, #ff4500, #ff8c00, #ffd700);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 20px rgba(255, 107, 53, 0.5);
    }
    
    .menu {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      width: 300px;
    }
    
    .menu-btn {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: inherit;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .menu-btn:hover {
      background: rgba(255, 107, 53, 0.2);
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    
    /* Upload de imagem */
    .image-upload {
      margin: 15px 0;
      text-align: center;
    }
    
    .upload-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px dashed rgba(255, 255, 255, 0.3);
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }
    
    .upload-btn:hover {
      background: rgba(255, 107, 53, 0.2);
      border-color: var(--accent);
    }
    
    .image-preview {
      margin-top: 10px;
      max-width: 100px;
      max-height: 100px;
      border-radius: 6px;
      display: none;
    }
    
    /* Tela de personagens */
    #characterScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #071021 0%, #0b1220 100%);
      z-index: 20;
      padding: 20px;
    }
    
    .character-title {
      font-size: 2.5rem;
      margin-bottom: 2rem;
      background: linear-gradient(to right, #ff4500, #ff8c00, #ffd700);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .character-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin: 2rem 0;
      max-width: 800px;
    }
    
    .character-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 25px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 2px solid transparent;
      min-width: 250px;
    }
    
    .character-card:hover {
      transform: translateY(-5px);
      background: rgba(255, 255, 255, 0.08);
    }
    
    .character-card.selected {
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(255, 107, 53, 0.4);
      background: rgba(255, 107, 53, 0.1);
    }
    
    .character-icon {
      font-size: 3rem;
      margin-bottom: 15px;
    }
    
    .character-name {
      font-size: 1.4rem;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .character-ability {
      font-size: 1rem;
      color: var(--accent);
      margin-bottom: 8px;
    }
    
    .character-desc {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.4;
    }
    
    .character-cooldown {
      font-size: 0.8rem;
      color: var(--muted);
      margin-top: 8px;
    }
    
    /* Jogo principal - ESCONDIDO por padr√£o */
    #gameContainer {
      display: none;
      position: relative;
    }
    
    .wrap {
      display: flex;
      gap: 24px;
      padding: 28px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
      box-shadow: 0 8px 30px rgba(2, 6, 23, 0.6);
    }
    
    .game-area {
      position: relative;
    }
    
    canvas {
      background: linear-gradient(180deg, #071024 0, #081028 100%);
      image-rendering: pixelated;
      border-radius: 6px;
    }
    
    /* Efeito do jato branco */
    .jet-effect {
      position: absolute;
      right: -50px;
      top: 0;
      width: 40px;
      height: 100%;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(255, 255, 255, 0.8) 20%, 
        rgba(255, 255, 255, 0.4) 50%, 
        transparent 100%);
      opacity: 0;
      pointer-events: none;
      z-index: 5;
      border-radius: 10px;
    }
    
    .jet-effect.active {
      animation: jetAnimation 0.6s ease-out;
    }
    
    @keyframes jetAnimation {
      0% {
        opacity: 0;
        transform: translateX(0) scaleX(0.3);
      }
      50% {
        opacity: 1;
        transform: translateX(-20px) scaleX(1);
      }
      100% {
        opacity: 0;
        transform: translateX(-40px) scaleX(0.1);
      }
    }
    
    .side {
      width: 220px;
    }
    
    h1 {
      font-size: 20px;
      margin: 0 0 8px;
      color: var(--accent);
    }
    
    .stat {
      margin: 8px 0;
      padding: 10px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
    }
    
    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    button {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 8px 10px;
      border-radius: 8px;
      color: inherit;
      cursor: pointer;
    }
    
    footer {
      font-size: 12px;
      color: var(--muted);
      margin-top: 12px;
    }
    
    .kbd {
      display: inline-block;
      padding: 4px 6px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.02);
      border: 1px solid rgba(255, 255, 255, 0.03);
    }
    
    .character-info {
      margin-top: 12px;
      padding: 10px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
    }
    
    .character-name-small {
      font-weight: bold;
      color: var(--accent);
      font-size: 14px;
    }
    
    .ability-bar {
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      margin-top: 6px;
      overflow: hidden;
    }
    
    .ability-fill {
      height: 100%;
      border-radius: 4px;
      width: 0%;
      transition: width 0.3s ease;
    }

    /* Game Over Modal (NOVO) */
    #gameOverModal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      z-index: 30;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 20px;
    }
    
    .game-over-content {
      background: var(--panel);
      padding: 40px;
      border-radius: 12px;
      box-shadow: 0 0 30px rgba(255, 107, 53, 0.6);
      max-width: 450px;
      width: 100%;
    }
    
    .game-over-title {
      font-size: 3rem;
      color: var(--accent);
      margin-bottom: 20px;
      text-shadow: 0 0 10px var(--accent);
    }
    
    .leaderboard-title {
      font-size: 1.8rem;
      margin-top: 30px;
      margin-bottom: 15px;
      color: #e6eef6;
    }
    
    #leaderboardList {
      list-style: none;
      padding: 0;
      margin: 0;
      text-align: left;
    }
    
    #leaderboardList li {
      display: flex;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
      font-size: 1.1rem;
    }
    
    #leaderboardList li:last-child {
      border-bottom: none;
    }
    
    #leaderboardList li:first-child {
      font-weight: bold;
      color: #ffd700;
      background: rgba(255, 215, 0, 0.1);
      border-radius: 4px;
    }
    
    .game-over-score {
      font-size: 2rem;
      color: #ffd700;
      margin-bottom: 20px;
    }
    
    /* Novo estilo para o bot√£o de compartilhamento */
    #btnShareScore {
        background: #007bff; /* Azul para destaque social */
        border: none;
        margin-top: 20px;
        padding: 12px 20px;
        font-size: 1.1rem;
        transition: background 0.2s;
    }
    
    #btnShareScore:hover {
        background: #0056b3;
    }
  </style>
</head>
<body>
  <div id="startScreen">
    <div class="logo">üî• TETRIS: Flamezera Edition üî•</div>
    <div class="menu">
      <button id="btnPlay" class="menu-btn">Jogar</button>
      <button id="btnCharacters" class="menu-btn">Personagens</button>
    </div>
  </div>
  
  <div id="characterScreen">
    <div class="character-title">Selecione seu Personagem</div>
    <div class="character-grid">
      <div class="character-card" data-character="flamezera">
        <div class="character-icon">üî•</div>
        <div class="character-name">Flamezera</div>
        <div class="character-ability">üî• Combust√£o</div>
        <div class="character-desc">Limpa uma linha extra quando completa 2 ou mais linhas de uma vez</div>
        <div class="character-cooldown">Recarga: 15 linhas</div>
      </div>
      <div class="character-card" data-character="frostbyte">
        <div class="character-icon">‚ùÑÔ∏è</div>
        <div class="character-name">Frostbyte</div>
        <div class="character-ability">‚ùÑÔ∏è Congelar</div>
        <div class="character-desc">Desacelera a queda das pe√ßas pela metade por 5 segundos</div>
        <div class="character-cooldown">Recarga: 20 linhas</div>
      </div>
      <div class="character-card" data-character="volt">
        <div class="character-icon">‚ö°</div>
        <div class="character-name">Volt</div>
        <div class="character-ability">‚ö° Descarga</div>
        <div class="character-desc">Apaga blocos aleat√≥rios da linha de base do tabuleiro</div>
        <div class="character-cooldown">Recarga: 12 linhas</div>
      </div>
      <div class="character-card" data-character="terra">
        <div class="character-icon">ü™®</div>
        <div class="character-name">Terra</div>
        <div class="character-ability">ü™® Bloco Pesado</div>
        <div class="character-desc">Impede o colapso por 1 linha, dando uma segunda chance</div>
        <div class="character-cooldown">Recarga: 10 linhas</div>
      </div>
      <div class="character-card" data-character="spectra">
        <div class="character-icon">üí´</div>
        <div class="character-name">Spectra</div>
        <div class="character-ability">üí´ Fase Fantasma</div>
        <div class="character-desc">Permite atravessar pe√ßas fixas por 3 segundos</div>
        <div class="character-cooldown">Recarga: 25 linhas</div>
      </div>
      <div class="character-card" data-character="denis">
        <div class="character-icon">üöÄ</div>
        <div class="character-name">Denis</div>
        <div class="character-ability">üöÄ Propuls√£o</div>
        <div class="character-desc">Blocos especiais com efeito de propuls√£o ao completar linhas</div>
        <div class="character-cooldown">Recarga: 8 linhas</div>
        <div class="image-upload">
          <label class="upload-btn">
            üì∑ Carregar Imagem
            <input type="file" id="imageInput" accept="image/*" style="display: none;">
          </label>
          <img id="imagePreview" class="image-preview" alt="Preview">
        </div>
      </div>
    </div>
    <div class="menu">
      <button id="btnSelectCharacter" class="menu-btn">Selecionar Personagem</button>
      <button id="btnBackFromCharacters" class="menu-btn">Voltar ao Menu</button>
    </div>
  </div>
  
  <div id="gameContainer">
    <div class="wrap">
      <div class="game-area">
        <canvas id="board" width="400" height="800"></canvas>
        <div class="jet-effect" id="jetEffect"></div>
      </div>
      <div class="side">
        <h1>TETRIS ‚Äî Flamezera Edition</h1>
        <div class="stat">Score: <strong id="score">0</strong></div>
        <div class="stat">Level: <strong id="level">1</strong></div>
        <div class="stat">Lines: <strong id="lines">0</strong></div>
        <div class="character-info">
          <div class="character-name-small" id="currentCharacter">Flamezera üî•</div>
          <div id="abilityDesc">Combust√£o: Limpa linha extra</div>
          <div class="ability-bar">
            <div class="ability-fill" id="abilityFill"></div>
          </div>
        </div>
        <div class="stat">Next:</div>
        <canvas id="next" width="160" height="160" style="display:block;border-radius:6px;margin-top:6px"></canvas>
        <div style="height:12px"></div>
        <div class="controls">
          <button id="btnStart">Iniciar</button>
          <button id="btnPause">Pausar</button>
          <button id="btnReset">Reset</button>
          <button id="btnMenu">Menu Principal</button>
        </div>
        <footer>
          Controles: <span class="kbd">‚Üê ‚Üí</span> mover, <span class="kbd">‚Üë</span> girar, <span class="kbd">‚Üì</span> soft drop, <span class="kbd">Space</span> hard drop, <span class="kbd">E</span> poder
        </footer>
      </div>
    </div>
  </div>

  <div id="gameOverModal">
    <div class="game-over-content">
      <div class="game-over-title">FIM DE JOGO!</div>
      <div class="game-over-score">Sua Pontua√ß√£o: <strong id="finalScore">0</strong></div>
      
      <div class="leaderboard-title">üèÜ TOP 10 MELHORES JOGADORES üèÜ</div>
      <ul id="leaderboardList">
        </ul>
      
      <button id="btnPlayAgain" class="menu-btn" style="margin-top: 30px;">Jogar Novamente</button>
      <button id="btnShareScore" class="menu-btn">Compartilhar Score</button>
    </div>
  </div>

<script>
(() => {
  // Configura√ß√µes atualizadas para o jogo maior
  const COLS = 10, ROWS = 20, BLOCK = 40;
  const board = document.getElementById('board');
  const ctx = board.getContext('2d');
  board.style.width = COLS * BLOCK + 'px';
  board.style.height = ROWS * BLOCK + 'px';
  board.width = COLS * BLOCK;
  board.height = ROWS * BLOCK;

  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');
  nextCanvas.width = 4*BLOCK; 
  nextCanvas.height = 4*BLOCK;

  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const currentCharacterEl = document.getElementById('currentCharacter');
  const abilityDescEl = document.getElementById('abilityDesc');
  const abilityFillEl = document.getElementById('abilityFill');
  const jetEffect = document.getElementById('jetEffect');
  const imageInput = document.getElementById('imageInput');
  const imagePreview = document.getElementById('imagePreview');

  // Elementos de UI (NOVO)
  const gameOverModal = document.getElementById('gameOverModal');
  const finalScoreEl = document.getElementById('finalScore');
  const leaderboardListEl = document.getElementById('leaderboardList');
  const btnPlayAgain = document.getElementById('btnPlayAgain');
  const btnShareScore = document.getElementById('btnShareScore');

  // Elementos de UI
  const startScreen = document.getElementById('startScreen');
  const characterScreen = document.getElementById('characterScreen');
  const gameContainer = document.getElementById('gameContainer');
  const btnPlay = document.getElementById('btnPlay');
  const btnCharacters = document.getElementById('btnCharacters');
  const btnSelectCharacter = document.getElementById('btnSelectCharacter');
  const btnBackFromCharacters = document.getElementById('btnBackFromCharacters');
  const btnMenu = document.getElementById('btnMenu');
  const characterCards = document.querySelectorAll('.character-card');

  // Imagem customizada para o Denis
  let customImage = null;
  let imageLoaded = false;

  // Sistema de upload de imagem
  imageInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = function(event) {
        const img = new Image();
        img.onload = function() {
          customImage = img;
          imageLoaded = true;
          imagePreview.src = event.target.result;
          imagePreview.style.display = 'block';
          console.log('Imagem carregada com sucesso!');
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }
  });

  // Definir personagens e seus poderes
  const CHARACTERS = {
    flamezera: {
      name: "Flamezera",
      icon: "üî•",
      ability: "Combust√£o",
      description: "Limpa linha extra ao completar 2+ linhas",
      cooldown: 15,
      currentCharge: 0,
      active: false,
      color: "linear-gradient(to right, #ff4500, #ff8c00)"
    },
    frostbyte: {
      name: "Frostbyte", 
      icon: "‚ùÑÔ∏è",
      ability: "Congelar",
      description: "Desacelera a queda por 5 segundos",
      cooldown: 20,
      currentCharge: 0,
      active: false,
      color: "linear-gradient(to right, #00bfff, #87cefa)"
    },
    volt: {
      name: "Volt",
      icon: "‚ö°", 
      ability: "Descarga",
      description: "Apaga blocos aleat√≥rios da base",
      cooldown: 12,
      currentCharge: 0,
      active: false,
      color: "linear-gradient(to right, #ffff00, #ffd700)"
    },
    terra: {
      name: "Terra",
      icon: "ü™®",
      ability: "Bloco Pesado", 
      description: "Impede colapso por 1 linha",
      cooldown: 10,
      currentCharge: 0,
      active: false,
      color: "linear-gradient(to right, #228b22, #32cd32)"
    },
    spectra: {
      name: "Spectra",
      icon: "üí´",
      ability: "Fase Fantasma",
      description: "Atravessa pe√ßas por 3 segundos", 
      cooldown: 25,
      currentCharge: 0,
      active: false,
      color: "linear-gradient(to right, #8a2be2, #9370db)"
    },
    denis: {
      name: "Denis",
      icon: "üöÄ",
      ability: "Propuls√£o",
      description: "Blocos especiais com efeito de propuls√£o",
      cooldown: 8,
      currentCharge: 0,
      active: false,
      color: "linear-gradient(to right, #ffffff, #cccccc)"
    }
  };

  let selectedCharacter = 'flamezera';

  // Tetromino definitions
  const TETROMINOES = {
    I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    J: [[1,0,0],[1,1,1],[0,0,0]],
    L: [[0,0,1],[1,1,1],[0,0,0]],
    O: [[1,1],[1,1]],
    S: [[0,1,1],[1,1,0],[0,0,0]],
    T: [[0,1,0],[1,1,1],[0,0,0]],
    Z: [[1,1,0],[0,1,1],[0,0,0]]
  };

  // Cores padr√£o
  const COLORS = {
    I:'#00f0f0', J:'#0000f0', L:'#f0a000', O:'#f0f000', S:'#00f000', T:'#a000f0', Z:'#f00000'
  };

  // Game state
  let grid = createMatrix(COLS, ROWS);
  let current = null;
  let next = null;
  let dropCounter = 0;
  let dropInterval = 1000;
  let lastTime = 0;
  let score = 0, level = 1, lines = 0;
  let running = false;
  let abilityActive = false;
  let abilityTimer = 0;
  let consecutiveLines = 0;
  let slowModeActive = false;
  let ghostModeActive = false;

  // Fun√ß√£o para ativar o efeito do jato
  function activateJetEffect() {
    jetEffect.classList.remove('active');
    // For√ßar reflow
    void jetEffect.offsetWidth;
    jetEffect.classList.add('active');
  }

  // Event listeners para a UI
  btnPlay.addEventListener('click', () => {
    startScreen.style.display = 'none';
    gameContainer.style.display = 'block';
    reset();
    start();
  });

  btnCharacters.addEventListener('click', () => {
    startScreen.style.display = 'none';
    characterScreen.style.display = 'flex';
  });

  btnSelectCharacter.addEventListener('click', () => {
    characterScreen.style.display = 'none';
    gameContainer.style.display = 'block';
    updateCharacterUI();
    reset();
    start();
  });

  btnBackFromCharacters.addEventListener('click', () => {
    characterScreen.style.display = 'none';
    startScreen.style.display = 'flex';
  });

  btnMenu.addEventListener('click', () => {
    gameContainer.style.display = 'none';
    startScreen.style.display = 'flex';
    running = false;
  });

  // Listener para o bot√£o 'Jogar Novamente' (NOVO)
  btnPlayAgain.addEventListener('click', () => {
    gameOverModal.style.display = 'none';
    reset();
    start();
  });

  // Listener para o bot√£o 'Compartilhar' (NOVO)
  btnShareScore.addEventListener('click', () => {
      const finalScore = document.getElementById('finalScore').textContent;
      const charName = CHARACTERS[selectedCharacter].name;
      const shareText = `üî•üî• NOVO RECORD! Fiz ${finalScore} pontos jogando com ${charName} no TETRIS: Flamezera Edition! Voc√™ consegue me superar? Jogue agora!`;
      
      if (navigator.share) {
          navigator.share({
              title: 'TETRIS: Flamezera Edition',
              text: shareText,
              url: window.location.href,
          }).catch(console.error);
      } else {
          navigator.clipboard.writeText(shareText + ' (Link do jogo: ' + window.location.href + ')');
          alert('Mensagem copiada para a √°rea de transfer√™ncia! Cole nas suas redes sociais:\n\n' + shareText);
      }
  });


  // Sele√ß√£o de personagens
  characterCards.forEach(card => {
    card.addEventListener('click', () => {
      characterCards.forEach(c => c.classList.remove('selected'));
      card.classList.add('selected');
      selectedCharacter = card.getAttribute('data-character');
    });
  });

  // Selecionar Flamezera por padr√£o
  characterCards[0].classList.add('selected');

  // Atualizar UI do personagem
  function updateCharacterUI() {
    const char = CHARACTERS[selectedCharacter];
    currentCharacterEl.textContent = `${char.name} ${char.icon}`;
    abilityDescEl.textContent = `${char.ability}: ${char.description}`;
    abilityFillEl.style.background = char.color;
    updateAbilityBar();
  }

  // Atualizar barra de habilidade
  function updateAbilityBar() {
    const char = CHARACTERS[selectedCharacter];
    const percent = (char.currentCharge / char.cooldown) * 100;
    abilityFillEl.style.width = `${percent}%`;
    // Adicionar um brilho quando o poder estiver pronto
    if (percent === 100) {
      abilityFillEl.style.boxShadow = '0 0 8px #ffd700';
    } else {
      abilityFillEl.style.boxShadow = 'none';
    }
  }

  // Ativar poder especial
  function activateAbility() {
    const char = CHARACTERS[selectedCharacter];
    
    if (char.currentCharge >= char.cooldown && !char.active) {
      char.active = true;
      char.currentCharge = 0;
      abilityActive = true;
      
      switch(selectedCharacter) {
        case 'flamezera':
          // Efeito aplicado na sweep()
          break;
        case 'frostbyte':
          slowModeActive = true;
          const originalInterval = dropInterval;
          dropInterval *= 2;
          setTimeout(() => {
            dropInterval = originalInterval;
            slowModeActive = false;
            char.active = false;
            abilityActive = false;
          }, 5000);
          break;
        case 'volt':
          // Remove blocos aleat√≥rios da base
          let blocksRemoved = 0;
          for (let x = 0; x < COLS; x++) {
            if (Math.random() < 0.4 && grid[ROWS-1][x]) {
              grid[ROWS-1][x] = 0;
              blocksRemoved++;
            }
          }
          // Se n√£o removeu da base, tenta uma linha acima
          if (blocksRemoved === 0) {
            for (let x = 0; x < COLS; x++) {
              if (Math.random() < 0.3 && grid[ROWS-2][x]) {
                grid[ROWS-2][x] = 0;
              }
            }
          }
          char.active = false;
          abilityActive = false;
          break;
        case 'terra':
          // Bloqueia colis√£o por uma jogada
          char.active = false;
          abilityActive = false;
          break;
        case 'spectra':
          ghostModeActive = true;
          setTimeout(() => {
            ghostModeActive = false;
            char.active = false;
            abilityActive = false;
          }, 3000);
          break;
        case 'denis':
          // Denis: Acelera o jogo por 10 segundos
          const originalSpeed = dropInterval;
          dropInterval = Math.max(50, dropInterval / 2);
          setTimeout(() => {
            dropInterval = originalSpeed;
            char.active = false;
            abilityActive = false;
          }, 10000);
          break;
      }
      
      updateAbilityBar();
      draw();
    }
  }

  // Fun√ß√µes do Leaderboard (NOVO)
  function getLeaderboard() {
    const scores = localStorage.getItem('tetrisFlamezeraLeaderboard');
    return scores ? JSON.parse(scores) : [];
  }

  function saveScore(newScore, characterName) {
    const leaderboard = getLeaderboard();
    
    leaderboard.push({
      score: newScore,
      char: characterName,
      date: new Date().toLocaleDateString('pt-BR')
    });
    
    // Ordena decrescente e mant√©m apenas o top 10
    leaderboard.sort((a, b) => b.score - a.score);
    const top10 = leaderboard.slice(0, 10);
    
    localStorage.setItem('tetrisFlamezeraLeaderboard', JSON.stringify(top10));
    return top10;
  }

  function displayLeaderboard(leaderboardData) {
    leaderboardListEl.innerHTML = '';
    if (leaderboardData.length === 0) {
      leaderboardListEl.innerHTML = '<li>Nenhuma pontua√ß√£o registrada ainda. Seja o primeiro!</li>';
      return;
    }
    
    leaderboardData.forEach((item, index) => {
      const isNewRecord = item.score === score && item.char === CHARACTERS[selectedCharacter].name && index === 0;
      const li = document.createElement('li');
      li.innerHTML = `
        <span>${index + 1}. ${item.char}</span> 
        <strong>${item.score}</strong>
      `;
      if (index === 0) li.style.fontWeight = 'bold';
      if (isNewRecord) li.style.color = '#ffd700'; // Destaque se for o novo recorde
      
      leaderboardListEl.appendChild(li);
    });
  }

  // Utilities
  function createMatrix(w,h){
    const m = [];
    for(let y=0;y<h;y++) m.push(new Array(w).fill(0));
    return m;
  }

  function rotate(matrix){
    const m = matrix.map(row=>row.slice());
    for(let y=0;y<m.length;y++) for(let x=0;x<y;x++) [m[x][y],m[y][x]]=[m[y][x],m[x][y]];
    m.forEach(r=>r.reverse());
    return m;
  }

  function randomPiece(){
    const keys = Object.keys(TETROMINOES);
    const type = keys[Math.floor(Math.random()*keys.length)];
    const shape = TETROMINOES[type].map(row=>row.slice());
    return {type, shape, x: Math.floor((COLS - shape[0].length)/2), y: -shape.length + 1};
  }

  function collide(grid, piece){
    // Se Spectra est√° ativo, n√£o h√° colis√£o
    if (ghostModeActive) {
      return false;
    }
    
    const m = piece.shape;
    for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++){
      if(m[y][x]){
        const gx = piece.x + x;
        const gy = piece.y + y;
        if(gy<0) continue;
        if(gx<0 || gx>=COLS || gy>=ROWS) return true;
        if(grid[gy][gx]) return true;
      }
    }
    return false;
  }

  function merge(grid, piece){
    piece.shape.forEach((row,y)=>row.forEach((val,x)=>{
      if(val && piece.y + y >= 0) grid[piece.y + y][piece.x + x] = piece.type;
    }));
  }

  function sweep(){
    let rowCount = 0;
    outer: for(let y=ROWS-1;y>=0;y--){
      for(let x=0;x<COLS;x++) if(!grid[y][x]) continue outer;
      const row = grid.splice(y,1)[0].fill(0);
      grid.unshift(row);
      y++;
      rowCount++;
    }
    
    if(rowCount>0){
      consecutiveLines += rowCount;
      
      // Poder do Flamezera
      if (selectedCharacter === 'flamezera' && consecutiveLines >= 2 && CHARACTERS.flamezera.active) {
        for (let y = ROWS-1; y >= 0; y--) {
          let full = true;
          for (let x = 0; x < COLS; x++) {
            if (!grid[y][x]) {
              full = false;
              break;
            }
          }
          if (full) {
            const row = grid.splice(y,1)[0].fill(0);
            grid.unshift(row);
            rowCount++;
            break;
          }
        }
        CHARACTERS.flamezera.active = false;
        abilityActive = false;
      }
      
      // Efeito especial do Denis - jato branco
      if (selectedCharacter === 'denis') {
        activateJetEffect();
      }
      
      const points = [0,40,100,300,1200];
      score += (points[rowCount] || 0) * level;
      lines += rowCount;
      level = Math.floor(lines/10) + 1;
      // Adicionar b√¥nus por combos (consecutiveLines > 1)
      if (consecutiveLines > 1) {
          score += 50 * consecutiveLines * level;
      }

      dropInterval = Math.max(100, 1000 - (level-1)*80);
      
      // Carregar habilidade
      CHARACTERS[selectedCharacter].currentCharge += rowCount;
      if (CHARACTERS[selectedCharacter].currentCharge > CHARACTERS[selectedCharacter].cooldown) {
        CHARACTERS[selectedCharacter].currentCharge = CHARACTERS[selectedCharacter].cooldown;
      }
      
      updateUI();
      updateAbilityBar();
    } else {
      consecutiveLines = 0;
    }
  }

  function updateUI(){
    scoreEl.textContent = score;
    levelEl.textContent = level;
    linesEl.textContent = lines;
  }

  function hardDrop(){
    while(!collide(grid, current)) current.y++;
    current.y--;
    lockPiece();
  }

  function lockPiece(){
    // Verificar poder da Terra
    if (selectedCharacter === 'terra' && CHARACTERS.terra.active && current.y < 0) {
      // Impedir colapso por uma linha - d√° uma segunda chance
      current.y = 0;
      CHARACTERS.terra.active = false;
      abilityActive = false;
      return; // N√£o trava a pe√ßa ainda
    }
    
    merge(grid, current);
    sweep();
    spawn();
    if(collide(grid, current)) endGame();
  }

  function spawn(){
    current = next || randomPiece();
    next = randomPiece();
    current.x = Math.floor((COLS - current.shape[0].length)/2);
    current.y = -current.shape.length + 1;
    drawNext();
  }

  function endGame(){
    running = false;
    // (NOVO) Salva e exibe a pontua√ß√£o
    const topScores = saveScore(score, CHARACTERS[selectedCharacter].name);
    finalScoreEl.textContent = score;
    displayLeaderboard(topScores);
    
    // (NOVO) Exibe o modal de Game Over
    gameOverModal.style.display = 'flex';
  }

  // Fun√ß√£o para desenhar uma pe√ßa inteira do Denis com imagem esticada
  function drawDenisPiece(piece, gridX, gridY) {
    if (!imageLoaded || !customImage) return;

    const shape = piece.shape;
    const width = shape[0].length;
    const height = shape.length;
    
    // Encontrar os limites da pe√ßa
    let minX = width, maxX = 0, minY = height, maxY = 0;
    let hasBlocks = false;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        if (shape[y][x]) {
          hasBlocks = true;
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }
      }
    }
    
    if (!hasBlocks) return;
    
    const pieceWidth = (maxX - minX + 1) * BLOCK;
    const pieceHeight = (maxY - minY + 1) * BLOCK;
    const startX = (gridX + minX) * BLOCK;
    const startY = (gridY + minY) * BLOCK;
    
    // Desenhar a imagem esticada para cobrir toda a pe√ßa
    ctx.drawImage(customImage, startX, startY, pieceWidth, pieceHeight);
    
    // Adicionar bordas para separar visualmente os blocos
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.lineWidth = 1;
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        if (shape[y][x]) {
          const px = (gridX + x) * BLOCK;
          const py = (gridY + y) * BLOCK;
          ctx.strokeRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
        }
      }
    }
  }

  // Fun√ß√£o para desenhar blocos fixos do Denis no grid
  function drawDenisGridBlock(x, y, type) {
    const px = x * BLOCK;
    const py = y * BLOCK;
    
    if (imageLoaded && customImage) {
      // Para blocos fixos no grid, desenhar a imagem em cada bloco individualmente
      ctx.drawImage(customImage, px + 1, py + 1, BLOCK - 2, BLOCK - 2);
      
      // Borda para separa√ß√£o visual
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.lineWidth = 1;
      ctx.strokeRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
    } else {
      // Fallback
      const gradient = ctx.createLinearGradient(px, py, px + BLOCK, py + BLOCK);
      gradient.addColorStop(0, '#ffffff');
      gradient.addColorStop(1, '#cccccc');
      ctx.fillStyle = gradient;
      ctx.fillRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
      ctx.strokeStyle = 'rgba(255,255,255,0.8)';
      ctx.lineWidth = 2;
      ctx.strokeRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
    }
  }

  // Fun√ß√£o para desenhar blocos normais
  function drawNormalBlock(x, y, type) {
    const px = x * BLOCK, py = y * BLOCK;
    ctx.fillStyle = type ? COLORS[type] : 'rgba(255,255,255,0.02)';
    ctx.fillRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
    if(type){
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 2;
      ctx.strokeRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
    }
  }

  // Drawing
  function drawCell(x, y, type) {
    if (selectedCharacter === 'denis' && type) {
      drawDenisGridBlock(x, y, type);
    } else {
      drawNormalBlock(x, y, type);
    }
  }

  function clear(){
    ctx.clearRect(0, 0, board.width, board.height);
    ctx.fillStyle = 'rgba(255,255,255,0.01)';
    ctx.fillRect(0, 0, board.width, board.height);
  }

  function draw(){
    clear();
    
    // Desenhar blocos fixos no grid
    for(let y = 0; y < ROWS; y++) {
      for(let x = 0; x < COLS; x++) {
        drawCell(x, y, grid[y][x]);
      }
    }
    
    // Desenhar pe√ßa atual
    if (current) {
      if (selectedCharacter === 'denis' && imageLoaded && customImage) {
        // Para o Denis, desenhar a pe√ßa inteira com imagem esticada
        drawDenisPiece(current, current.x, current.y);
      } else {
        // Para outros personagens, desenhar normalmente
        current.shape.forEach((row, dy) => {
          row.forEach((val, dx) => {
            if(val){
              const x = current.x + dx, y = current.y + dy;
              if(y >= 0) {
                if (ghostModeActive) {
                  ctx.globalAlpha = 0.6;
                  drawCell(x, y, current.type);
                  ctx.globalAlpha = 1.0;
                } else {
                  drawCell(x, y, current.type);
                }
              }
            }
          });
        });
      }
    }
  }

  function drawNext(){
    nctx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    nctx.fillStyle = 'rgba(255,255,255,0.01)';
    nctx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    
    const m = next.shape;
    const offX = Math.floor((4 - m[0].length) / 2);
    const offY = Math.floor((4 - m.length) / 2);
    
    if (selectedCharacter === 'denis' && imageLoaded && customImage) {
      // Para o Denis, desenhar a pr√≥xima pe√ßa com imagem esticada
      const width = m[0].length;
      const height = m.length;
      
      let minX = width, maxX = 0, minY = height, maxY = 0;
      let hasBlocks = false;
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          if (m[y][x]) {
            hasBlocks = true;
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }
        }
      }
      
      if (hasBlocks) {
        const pieceWidth = (maxX - minX + 1) * BLOCK;
        const pieceHeight = (maxY - minY + 1) * BLOCK;
        const startX = (offX + minX) * BLOCK;
        const startY = (offY + minY) * BLOCK;
        
        nctx.drawImage(customImage, startX, startY, pieceWidth, pieceHeight);
        
        // Bordas
        nctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
        nctx.lineWidth = 1;
        m.forEach((row, y) => row.forEach((val, x) => {
          if(val){
            const px = (offX + x) * BLOCK;
            const py = (offY + y) * BLOCK;
            nctx.strokeRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
          }
        }));
      }
    } else {
      // Desenho normal para outros personagens
      m.forEach((row, y) => row.forEach((val, x) => {
        if(val){
          const px = (offX + x) * BLOCK;
          const py = (offY + y) * BLOCK;
          nctx.fillStyle = COLORS[next.type];
          nctx.fillRect(px + 1, py + 1, BLOCK - 2, BLOCK - 2);
        }
      }));
    }
  }

  // Input
  document.addEventListener('keydown', e => {
    if(!running) return;
    if(e.key === 'ArrowLeft'){
      current.x--; if(collide(grid, current)) current.x++; draw();
    } else if(e.key === 'ArrowRight'){
      current.x++; if(collide(grid, current)) current.x--; draw();
    } else if(e.key === 'ArrowDown'){
      current.y++; if(collide(grid, current)){ current.y--; lockPiece(); } draw();
    } else if(e.key === 'ArrowUp'){
      const prev = current.shape;
      current.shape = rotate(current.shape);
      if(collide(grid, current)) current.shape = prev; draw();
    } else if(e.code === 'Space'){
      hardDrop(); draw();
    } else if(e.key === 'e' || e.key === 'E'){
      activateAbility();
    }
  });

  // Buttons do jogo
  document.getElementById('btnStart').addEventListener('click', () => { 
    if(!running) start(); 
  });
  
  document.getElementById('btnPause').addEventListener('click', () => { 
    running = !running; 
    document.getElementById('btnPause').textContent = running ? 'Pausar' : 'Retomar'; 
  });
  
  document.getElementById('btnReset').addEventListener('click', () => { 
    reset(); 
  });

  function reset(){
    grid = createMatrix(COLS, ROWS);
    score = 0; level = 1; lines = 0; dropInterval = 1000; 
    consecutiveLines = 0;
    slowModeActive = false;
    ghostModeActive = false;
    
    CHARACTERS[selectedCharacter].currentCharge = 0;
    CHARACTERS[selectedCharacter].active = false;
    abilityActive = false;
    
    updateUI();
    updateAbilityBar();
    next = randomPiece(); 
    spawn(); 
    draw();
  }

  function start(){
    if(!running){ 
      running = true; 
      lastTime = performance.now(); 
      requestAnimationFrame(update); 
    }
  }

  function update(time = 0){
    if(!running) return;
    const delta = time - lastTime;
    lastTime = time;
    
    dropCounter += delta;
    if(dropCounter > dropInterval){
      current.y++;
      if(collide(grid, current)){
        current.y--;
        lockPiece();
      }
      dropCounter = 0;
    }
    draw();
    requestAnimationFrame(update);
  }

  // Inicializar
  updateCharacterUI();
  reset();
})();
</script>
</body>
</html>
